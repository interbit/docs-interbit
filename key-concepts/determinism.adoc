= Determinism

Determinism (in software development)::
  Given a particular state, and a specific set of input, the result is
  **always** the same.

Determinism is an important concept to understand before developing an
Interbit application.

A blockchain is a distributed database representing a current state.
Multiple nodes cooperate in a network to provide the distribution of the
database, and maintain the blockchain's state. Previously recorded state
is immutable, and new state is added to the blockchain via consensus.

Consensus is the mechanism used to decide which state changes -- or
_actions_ are valid. Typical blockchains use mechanisms such as Proof of
Work, which involves solving hard-to-compute problems that are easy to
verify, or Proof of Stake, which limits a user's action processing to
the their relative financial investment in the blockchain. Interbit
blockchains use Proof of Authority: as every user is identified by a
public key, changes to the blockchain's state can be made under a user's
authority.

This means that only one node needs to decide whether an action is
valid. Once an action is deemed valid, it is dispatched to all nodes and
each node executes the blockchain's link:smart_contracts.adoc[smart
contract] to change their copy of the state in the same way.

This is where determinism is involved: for all nodes to arrive at the
same state, each node must start from the initial state (or a known
blockchain state), execute the same smart contracts with the same inputs
in the same order, and get the same results from each smart contract
method.

If the smart contract processing is not deterministic, then there could
be differences in the state across the supporting nodes. If this were
allowed to happen, the blockchain would be split -- or _forked_ -- into
multiple, distinct blockchains that would be incompatible with each
other.

An action that is non-deterministic is called a _side effect_. One
example would be an action to "store the current date and time". Even
though each node receives a dispatched action over a short time period,
they do not receive actions simultaneously, and their ability to execute
the smart contract can vary. The side effect of this action is that each
node could end up recording a different date and time.

The strategy to use in this case is have your app first determine the
current date and time, and then dispatch an action using this determined
information. In many cases, side effects can be avoided by using this
strategy.

There are several classes of processing that are inherently
non-deterministic and produce side effects:

- Time
- Randomness
- File operations
- API calls

For these cases, the strategy to use is called a link:sagas.adoc[saga].
A saga is a list of one or more steps that need to be executed to
collect information to achieve a larger goal.

For example, if you want to book a trip, your trip might involve
reserving a flight, hotel, and rental vehicle. Making the reservations
requires communicating with each provider, can take a notable amount
of time, and could fail for any number of reasons. If any of the
reservations fails, the trip has to be considered "not booked"; it is
not useful to reserve a hotel and rental vehicle if you cannot reserve a
flight.

A saga could process each of the reservation requests, retrying if any
of the service providers is temporarily unavailable, and -- once all of the
requests are complete -- dispatch the booked trip to the blockchain. If
the saga was interrupted during processing, the trip also would not be
booked.

However you implement your smart contract, determinism is the number one
consideration! Failure is okay, provided that it fails the same way each
time.
